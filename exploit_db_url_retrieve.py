from selenium import webdriver
from selenium.webdriver.support.ui import Select
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import StaleElementReferenceException

from cve_core import print_update, EXPLOIT_DB_URLS_FILE
import traceback

# path to binary executable
CHROMEPATH = '/Users/HomeFolder/Downloads/--other--/chromedriver'
# make it headless
chrome_options = Options()
chrome_options.add_argument("--headless")

def get_paginate_next_button(driver):
	"""get the button that leads to the next page"""
	return tuple(
		filter(lambda s: s.get_attribute('class')=='paginate_button page-item next',
		driver.find_elements_by_class_name("paginate_button"))
	)[0]

def get_paginate_active_button(driver):
	"""get the button that indicates the active page"""
	return tuple(
		filter(lambda s: s.get_attribute('class')=='paginate_button page-item active',
		driver.find_elements_by_class_name("paginate_button"))
	)[0]

def get_current_page(driver):
	"""get the current page number"""
	return int(get_paginate_active_button(driver).find_element_by_tag_name('a').text)

class ActivePageCheck:
	"""
	__call__ an instance of this class to see if the current page
	matches the expectation, if the page is loaded yet.
	
	Used in combination with selenium wait functionality.
	"""
	def __init__(self,expected_page, function_to_call, *a, **kw):
		self.expected_page=int(expected_page)
		self.func = function_to_call
		self.args = a
		self.kwargs = kw
	
	def __call__(self,driver):
		try:
			if get_current_page(driver) == self.expected_page:
				return self.func(driver, *self.args, **self.kwargs)
			return False
		except IndexError: return False
		except StaleElementReferenceException: return False

class TableLengthCheck:
	"""
	__call__ an instance of this class to see if the table length
	matches the expectation; used after page has already been loaded.
	
	Used in combination with selenium wait functionality.
	"""
	def __init__(self, length):
		self.length = length
	
	def __call__(self,driver):
		#print('calling TableLengthCheck')
		text = driver.find_element_by_class_name('dataTables_info').text
		#print(f'table length text: <{text}>')
		return f'to {self.length} of' in text

def get_exploit_links(driver):
	"""
	Extract all links to exploit pages from the current pagination index.
	"""
	# get the table containing exploit data
	table = list(filter(
		lambda t: t.get_attribute('id')=='exploits-table',
		driver.find_elements_by_tag_name('table')
	))[0]
	
	# get table rows
	rows = table.find_element_by_tag_name('tbody').find_elements_by_tag_name('tr')
	
	# in each row, the fifth element contains the link of interest
	# get the <a ...> child from the row's fifth element
	# and get its 'href' attribute
	links = [row
		.find_elements_by_tag_name('td')[4]
		.find_element_by_tag_name('a')
		.get_attribute('href')
		for row in rows
	]
	
	# make sure links follow expected pattern
	assert all(
		a.startswith('https://www.exploit-db.com/exploits/')
		and str.isdigit(a.split('/')[-1])
		for a in links
	)
	
	# interested in the exploit number, unique identifier
	return [l.split('/')[-1] for l in links]

def get_length_button(driver):
	"""get the button that controls how many items are displayed per page"""
	return driver.find_element_by_name('exploits-table_length')

def move_to_next_page(driver, limit = 5):
	"""move to the next page, with waiting functionality implemented"""
	paginate_button = get_paginate_next_button(driver)
	current_page = get_current_page(driver)
	#print('moving to next page from page',current_page)
	wait = WebDriverWait(driver, limit)
	paginate_button.click()
	paginate_button = wait.until(ActivePageCheck(current_page+1,get_paginate_next_button))

if __name__ == '__main__':
	# start a headless chrome driver
	driver = webdriver.Chrome(CHROMEPATH, options=chrome_options)
	
	try:
		# the main page with the exploit table
		driver.get('https://www.exploit-db.com/')
		
		# the button controlling table size
		length_button = WebDriverWait(driver, 12).until(ActivePageCheck(1,get_length_button))
		
		# select 120 rows per page
		sel = Select(length_button)
		sel.select_by_value('120')
		WebDriverWait(driver, 8).until(TableLengthCheck(120))
		
		# get the last page in the current pagination scheme
		last_page = int(
			driver
				.find_element_by_id('exploits-table_paginate')
				.find_element_by_tag_name('ul')
				.find_elements_by_tag_name('li')[-3]
				.text
		)
		
		print('last page:',last_page)
		
		links=[]
		
		start_page = 1
		with open('exploit db urls.file') as f:
			while True:
				line = f.readline()
				if not line: break
				start_page = line[:line.index(':')]
		start_page = int(start_page)
		print('start page:',start_page)
		
		# cycle over pages, collecting links of interest from each page
		while True:
			current_page = get_current_page(driver)
			if current_page == start_page: break
			print_update('current page:',current_page)
			move_to_next_page(driver)
			
		while True:
			current_page = get_current_page(driver)
			new_links = get_exploit_links(driver)
			
			print_update(f'on page {current_page}/{last_page} ({type(current_page)}), first and last links (size={len(new_links)}):',(new_links[0],new_links[-1]))
			
			# write to disk rather than store in memory --
			# this way if something goes wrong, at most we lose only one page of data
			# rather than all pages we have visited
			with open(EXPLOIT_DB_URLS_FILE,'a') as f:
				f.write(f"{current_page}:{','.join(new_links)}\n")
			
			links.extend(new_links)
			#print()
			if current_page == last_page: break
			move_to_next_page(driver)
		
		print_update('')
		print(f'links: size={len(set(links))}')
	except Exception as e:
		print('exception occurred; closing browser')
		trace = traceback.format_exc().replace('\n','\n\t')
		print(f"\t{trace}")
	finally:
		driver.close()